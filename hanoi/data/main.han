
mod csv {

    let quoted = {};

    let parser = {
        bind caller;
        bind iter;
        bind next;
        caller next #curry iter #curry @exec;

        match (1) {
            @eos => {
                bind eos;
                bind caller;
                @end caller #curry @exec ^eos
            }
            @yield => {
                bind iternext;
                bind char;
                bind yld;
                bind caller;

                match (2) {
                    ',' => {
                        bind next;
                        iternext next #curry 
                            @nextfield caller #curry #curry @exec ^yld ^char;
                        bind caller;
                        bind iternext;
                        caller iternext this.parser #curry #curry @exec
                    }

                    '\n' => {
                        bind next; 
                            iternext next #curry 
                                @nextrow caller #curry #curry @exec ^yld ^char;
                        bind caller;
                        bind iternext;
                            caller iternext this.parser #curry #curry @exec
                    }
                } else {
                    bind next;
                        iternext next #curry char @fieldchar caller #curry #curry #curry @exec ^yld;
                    bind caller;
                    bind iternext;
                        caller iternext this.parser #curry #curry @exec

                }
            }
        } else {
            @panic
        }

    };
}

mod tests {
    let enumerate = {
        bind caller;
        bind next;
            next @assert_true @yield caller #curry #curry #curry @exec; 
        bind caller;
        bind next;
            next @another_one @yield caller #curry #curry #curry @exec;
        bind caller;
            @eos caller #curry @exec
    };

    mod cases {
        let assert_true = {
            bind caller;
                @pass caller #curry @exec
        };

        let another_one = {
            bind caller;
                @fail caller #curry @exec
        };
    }

    let run = {
        bind caller;
        bind case;
            caller case @cases this #get #get #curry @exec 
    };
}

mod iter {
    let symbol_len = {
        bind caller;
        bind symbol;
            symbol #symbol_len caller #curry @exec
    };

    let symbol_char_at = {
        bind caller;
        bind symbol;
        bind offset;
            symbol offset #symbol_char_at caller #curry @exec
    };

    let eq = {
        bind caller;
        bind a;
        bind b;
        a b #eq caller #curry @exec
    };

    let add = {
        bind caller;
        bind a;
        bind b;
            a b #add caller #curry @exec
    };

    let symbol_chars = {
        bind caller;
        bind symbol;
        bind offset;
        bind next;
            #sd(3)
            #ns_empty 
                @offset #mv(2) #ns_insert
                @symbol #mv(2) #ns_insert
                @caller #mv(2) #ns_insert
            @symbol #ns_get #mv(1)
            this.symbol_len #mv(1)
            #mv(3) #curry #sd(2)
            #curry #curry
            @exec;
        bind len;
        bind ns;
        bind next;
            #sd(2)
            @len #mv(2) #ns_insert
            @len #ns_remove #mv(1) 
            @offset #ns_get #mv(1)
            this.eq #mv(1)
            #mv(4) #curry #sd(3)
            #curry #curry #curry
            @exec;
        bind are_eq;
        bind ns;
            @are_eq #mv(2) #ns_insert
            @are_eq #ns_get if {
                bind ns;
                    @eos #mv(1) 
                    @caller #ns_remove #mv(1)
                    #drop(0)
                    #curry
                    @exec
            } else {
                bind ns;
                bind next;
                    #sd(1)
                    @symbol #ns_get #mv(1) 
                    @offset #ns_get #mv(1) 
                    this.symbol_char_at #mv(1)
                    #mv(4) #curry #sd(3) 
                    #curry #curry #curry
                    @exec;
                bind char_at;
                bind ns;
                bind next;
                    #sd(2)
                    @char_at #mv(2) #ns_insert

                    @char_at #ns_get #mv(1)
                    @yield #mv(1)
                    @caller #ns_remove #mv(1)
                    #mv(4) #curry #sd(3)
                    #curry #curry #curry
                    @exec;

                bind caller;
                bind ns;
                bind next;
                    #sd(2)
                    @caller #mv(2) #ns_insert

                    @offset #ns_remove #mv(1)
                    1 #mv(1)
                    this.add #mv(1)
                    #mv(4) #curry #sd(3)
                    #curry #curry #curry
                    @exec;

                bind sum;
                bind ns;
                    @sum #mv(2) #ns_insert

                    @caller #ns_remove #mv(1)
                    @symbol #ns_remove #mv(1)
                    @sum #ns_remove #mv(1)
                    this.symbol_chars #mv(1)
                    #drop(0)
                    #curry #curry #curry
                    @exec
            }
    };
}

let main = {
    bind next;
        @"h,e\n" 0 this.iter.symbol_chars #curry #curry
            this.csv.parser #curry #curry @exec;
    bind cont;
    bind char;
    bind tag;
    bind next;
        tag @fieldchar #assert_eq char 'h' #assert_eq next cont #curry @exec;
    bind cont;
    bind tag;
    bind next;
        tag @nextfield #assert_eq next cont #curry @exec;
    bind cont;
    bind char;
    bind tag;
    bind next;
        tag @fieldchar #assert_eq char 'e' #assert_eq next cont #curry @exec;
    bind cont;
    bind tag;
    bind next;
        tag @nextrow #assert_eq next cont #curry @exec;
    bind tag;
        tag @end #assert_eq
};